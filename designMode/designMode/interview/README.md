## 自我介绍
> 自我介绍
> * **基础信息：** 面试官您好，我叫刘成义，今年25岁，本科是南京理工大学，班级排名前25%，保送到至本校南理工继续读研究生，
> 本硕专业都是机械学院的工业工程专业。研究的方向为智能制造
> * **项目经历方面**：过去的两年研究生生活一共参与了三个项目的建设，分别是两个横向课题和一个纵向课题：
> 两个横向课题分别为：
>   * 一个集装箱港口的资源调度、优化与预测，我的职责是采用flexsim仿真建模与验证，
>   * 第二个项目为智能制造演示实验室的搭建，我主要运用python和opencv库参与了其中的视觉识别，验证产品打印质量，同时运用visual components对车间进行建模，
>   * 第三个也就是纵向课题项目是最大的一个项目，历时超过一年，主要针对某航空液压产品企业的智能生产线建设，
>   我参与了整个软件系统流程的设计，通过java和vue进行前后端界面与业务设计，系统上参与了框架构建，此外负责与该企业现有的erp、mes、plm进行集成，同时与还未正式上线但是准备投入使用的wms、agv等系统进行集成。
> * **竞赛方面**：20年借用当时参与的集装箱港口项目进行分析概括，总结后形成参赛稿参与了当年的清华IE亮剑工业工程案例大赛，获得了三等奖；此外，也参与过数学建模的校赛、华为杯等比赛，比较遗憾未能拿到名次
> **结语**：该项目与我想应聘的XX公司的XXXX职位比较匹配，谢谢


## 集装箱港口的资源调度要点

## 智能制造演示实验室
视觉识别的插值和均值hash算法
```python
#均值哈希算法
    def aHash(self,imgOriginal):
        #缩放为8*8
        imgOriginal=cv.resize(imgOriginal,(8,8),interpolation=cv.INTER_CUBIC)
        #转换为灰度图
        gray=cv.cvtColor(imgOriginal,cv.COLOR_BGR2GRAY)
        #s为像素和初值为0，hash_str为hash值初值为''
        s=0
        hash_str=''
        #遍历累加求像素和
        for i in range(8):
            for j in range(8):
                s=s+gray[i,j]
        #求平均灰度
        avg=s/64
        #灰度大于平均值为1相反为0生成图片的hash值
        for i in range(8):
            for j in range(8):
                if  gray[i,j]>avg:
                    hash_str=hash_str+'1'
                else:
                    hash_str=hash_str+'0'            
        return hash_str
    #差值感知算法
    def dHash(self,imgOriginal):
        #缩放8*8
        imgOriginal=cv.resize(imgOriginal,(9,8),interpolation=cv.INTER_CUBIC)
        #转换灰度图
        gray=cv.cvtColor(imgOriginal,cv.COLOR_BGR2GRAY)
        hash_str=''
        #每行前一个像素大于后一个像素为1，相反为0，生成哈希
        for i in range(8):
            for j in range(8):
                if   gray[i,j]>gray[i,j+1]:
                    hash_str=hash_str+'1'
                else:
                    hash_str=hash_str+'0'
        return hash_str
```

> 主要思路为 
> 1、将图片缩放为8*8
> 2、转换为灰度图
> 3、对于均值hash算法
>   
>   1. 遍历累加整个灰度图
>   2. 求均值
>   3. 对每一个区域，若该区域的灰度大于平均值则该区域的hash算为1
>   若该区域的灰度小于平均值则hash算为0
>   4. 最终生成hash码
> 4、对于差值hash算法
>   1. 对于每一行，若前一个区域的灰度大于后一个区域，则该区域的hash为1，否则为0
>   2. 最终生成hash码
> 5、（64-相似度/64）*100
> 6、最终的数据是大于等于84%左右，比较保守的一个数字
> 7、当时疫情，这个数字是个人估计的比较稳定的一个数字，手动采用手机进行拍照对比，光源需要固定，位置需要固定
>  比较局限，但是由于疫情期间，在家没有办法做实验


## HTTP的九种请求方式
* POST 表示向指定资源提交数据，数据包含在请求头中，有可能导致新的资源建立或原油资源的修改
* GET 表示请求指定的页面信息，并返回实体内容
* HEAD 用于获取报文头
* PUT 上传
* PATCH 对PUT 的补充，用来对已知资源进行局部更新
* OPTIONS，针对特殊资源，允许客户端查看服务器的性能
* DELETE 请求服务器删除
* CONNECT 将连接改为管道方式的代理服务器
* TRACE 回显服务器收到的请求，主要用于测试和诊断

### 深拷贝和浅拷贝的区别
浅拷贝：被拷贝的对象和原对象所有的变量的值都完全一致，而拷贝的对象所有引用其他对象的地方仍然指向
原有的对象，也就是说，浅拷贝仅仅复制原对象，而不复制其引用的对象
深拷贝：被拷贝的对象和原对象所有的变量的值都完全一致，被拷贝的对象所有的引用其他对象的地方都进行了复制，
而不再是原对象的引用，也就是说，深拷贝把原有的对象所引用的对象都复制了一遍

### NIO、BIO、AIO
* BIO ：Blocking-IO 同步阻塞IO
> 应用程序发起read调用后，会一直阻塞，直到内核吧数据拷贝到用户空间
> 使用特点：使用简单，面对十万甚至百万级的时候无能为力
* NIO：Non-Blocking-IO/New -IO 同步非阻塞IO
> 支持面向缓冲的，基于通道的I/O操作方法，对于高负载、高并发的应用  
> 基本原理是反复调用read，轮训操作系统直到可以开始进行数据拷贝  
> 真正进行数据拷贝的时候线程同样是会阻塞的
> 存在的问题：不断轮询的过程是十分耗费CPU资源的
> 
->改进型
>IO多路复用  
> 线程首先发起select调用，询问内核是否准备就绪，等内核准备号了，在进行read调用，但是调用的
> 过程还是阻塞的
> * 优点：通过减少无效的系统调用，减少了对CPU资源的消耗
> * Selector的概念，选择器，实现Java多路复用的本质，只需要一个线程便可以管理多个客户端连接
* AIO：Async-Blocking-IO 异步非阻塞IO
> 本质：基于事件和回调机制实现，也就是应用操作之后直接返回，不会堵塞，但后台处理完成，
> 操作系统会通知相应的县城进行后续的操作。
## 双向链表和单向链表
双向链表的优势：能够拿到父节点的引用，若需要对前置节点做处理，则双向链表更有优势
删除指定节点更有优势

## 如何停止一个正在运行的线程
1. 使用退出标志，run方法完成后
2. 使用stop、suspend、resume
3. 使用interrupt方法终端线程

## reentrantLock->可重入锁

